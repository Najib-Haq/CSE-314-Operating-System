diff --git a/Makefile b/Makefile
index 09d790c..8a56485 100644
--- a/Makefile
+++ b/Makefile
@@ -71,6 +71,14 @@ QEMU = $(shell if which qemu > /dev/null; \
 	echo "***" 1>&2; exit 1)
 endif
 
+ifndef VERBOSE
+	VERBOSE := NOPRINT
+endif
+
+ifndef ALGO
+	ALGO := FIFO
+endif
+
 CC = $(TOOLPREFIX)gcc
 AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
@@ -78,6 +86,7 @@ OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+CFLAGS += -D$(VERBOSE) -D$(ALGO) 
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
 LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
@@ -181,6 +190,8 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_test_swap\
+	_test_fork\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +228,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -250,7 +261,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
+	printf.c umalloc.c test_swap.c test_fork.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
diff --git a/console.c b/console.c
index a280d2b..60300ad 100644
--- a/console.c
+++ b/console.c
@@ -198,6 +198,7 @@ consoleintr(int (*getc)(void))
     switch(c){
     case C('P'):  // Process listing.
       // procdump() locks cons.lock indirectly; invoke later
+      // This is ctrl+p 
       doprocdump = 1;
       break;
     case C('U'):  // Kill line.
diff --git a/defs.h b/defs.h
index 82fb982..7e26305 100644
--- a/defs.h
+++ b/defs.h
@@ -9,6 +9,8 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct page_struct;
+struct file_offsets;
 
 // bio.c
 void            binit(void);
@@ -52,6 +54,11 @@ struct inode*   nameiparent(char*, char*);
 int             readi(struct inode*, char*, uint, uint);
 void            stati(struct inode*, struct stat*);
 int             writei(struct inode*, char*, uint, uint);
+int             createSwapFile(struct proc* p);
+int             readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size);
+int             writeToSwapFile(struct proc* p, char* buffer, uint placeOnFile, uint size);
+int             removeSwapFile(struct proc* p);
+
 
 // ide.c
 void            ideinit(void);
@@ -120,10 +127,26 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+// custom
+void            clearAccessBitForAll(void);
+
+// swap files stuff
+void            enqueue_page(struct proc*, struct page_struct*);
+struct page_struct* dequeue_page(struct proc*);
+int             get_free_index(struct proc* cur_proc);
+
+// file offset handling
+void            push_file_offsets(struct proc*, int);
+int             pop_file_offsets(struct proc*);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
 
+// sysfile
+struct inode*   create(char *path, short type, short major, short minor);
+int             isdirempty(struct inode *dp);
+
+
 // spinlock.c
 void            acquire(struct spinlock*);
 void            getcallerpcs(void*, uint*);
@@ -185,6 +208,14 @@ void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
+// custom
+void            printPTE(pde_t*, uint);
+void            print_proc_info(struct proc*);
+void            read_page_from_file(struct proc*, int, char*);
+void            write_page_to_file(struct proc*);
+int             swap_in_and_out(struct proc*, uint);
+struct page_struct* get_NRU_page(struct proc*);
+void            clearAccessBit(struct proc*);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/exec.c b/exec.c
index b40134f..ad6c167 100644
--- a/exec.c
+++ b/exec.c
@@ -18,6 +18,9 @@ exec(char *path, char **argv)
   struct proghdr ph;
   pde_t *pgdir, *oldpgdir;
   struct proc *curproc = myproc();
+  #if PRINT
+    cprintf("In exec : , proc id is %d and sz is %d\n", curproc->pid, curproc->sz);
+  #endif
 
   begin_op();
 
@@ -96,6 +99,11 @@ exec(char *path, char **argv)
   // Commit to the user image.
   oldpgdir = curproc->pgdir;
   curproc->pgdir = pgdir;
+
+  #if PRINT
+    cprintf("switched pgdir from %d to %d\n", *oldpgdir, *pgdir); 
+  #endif
+
   curproc->sz = sz;
   curproc->tf->eip = elf.entry;  // main
   curproc->tf->esp = sp;
diff --git a/file.c b/file.c
index 24b32c2..87fdfac 100644
--- a/file.c
+++ b/file.c
@@ -152,6 +152,7 @@ filewrite(struct file *f, char *addr, int n)
     }
     return i == n ? n : -1;
   }
+  if(f->type == FD_NONE) cprintf("File type : %d and none\n", f->type);
   panic("filewrite");
 }
 
diff --git a/fs.c b/fs.c
index f77275f..4966e79 100644
--- a/fs.c
+++ b/fs.c
@@ -668,3 +668,144 @@ nameiparent(char *path, char *name)
 {
   return namex(path, 1, name);
 }
+
+// NEW FOR PAGING
+
+#include "fcntl.h"
+#define DIGITS 14
+
+char* itoa(int i, char b[]){
+    char const digit[] = "0123456789";
+    char* p = b;
+    if(i<0){
+        *p++ = '-';
+        i *= -1;
+    }
+    int shifter = i;
+    do{ //Move to where representation ends
+        ++p;
+        shifter = shifter/10;
+    }while(shifter);
+    *p = '\0';
+    do{ //Move back, inserting digits as u go
+        *--p = digit[i%10];
+        i = i/10;
+    }while(i);
+    return b;
+}
+
+//remove swap file of proc p;
+int
+removeSwapFile(struct proc* p)
+{
+	//path of proccess
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+	struct inode *ip, *dp;
+	struct dirent de;
+	char name[DIRSIZ];
+	uint off;
+
+	if(0 == p->swapFile)
+	{
+		return -1;
+	}
+	fileclose(p->swapFile);
+
+	begin_op();
+	if((dp = nameiparent(path, name)) == 0)
+	{
+		end_op();
+		return -1;
+	}
+
+	ilock(dp);
+
+	  // Cannot unlink "." or "..".
+	if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+	   goto bad;
+
+	if((ip = dirlookup(dp, name, &off)) == 0)
+		goto bad;
+	ilock(ip);
+
+	if(ip->nlink < 1)
+		panic("unlink: nlink < 1");
+	if(ip->type == T_DIR && !isdirempty(ip)){
+		iunlockput(ip);
+		goto bad;
+	}
+
+	memset(&de, 0, sizeof(de));
+	if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+		panic("unlink: writei");
+	if(ip->type == T_DIR){
+		dp->nlink--;
+		iupdate(dp);
+	}
+	iunlockput(dp);
+
+	ip->nlink--;
+	iupdate(ip);
+	iunlockput(ip);
+
+	end_op();
+
+	return 0;
+
+	bad:
+		iunlockput(dp);
+		end_op();
+		return -1;
+
+}
+
+
+//return 0 on success
+int
+createSwapFile(struct proc* p)
+{
+
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+    begin_op();
+    struct inode * in = create(path, T_FILE, 0, 0);
+	iunlock(in);
+
+	p->swapFile = filealloc();
+	if (p->swapFile == 0)
+		panic("no slot for files on /store");
+
+	p->swapFile->ip = in;
+	p->swapFile->type = FD_INODE;
+	p->swapFile->off = 0;
+	p->swapFile->readable = O_WRONLY;
+	p->swapFile->writable = O_RDWR;
+    end_op();
+
+    return 0;
+}
+
+//return as sys_write (-1 when error)
+int
+writeToSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return filewrite(p->swapFile, buffer, size);
+
+}
+
+//return as sys_read (-1 when error)
+int
+readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return fileread(p->swapFile, buffer,  size);
+}
+
diff --git a/fs.c.orig b/fs.c.orig
new file mode 100644
index 0000000..f77275f
--- /dev/null
+++ b/fs.c.orig
@@ -0,0 +1,670 @@
+// File system implementation.  Five layers:
+//   + Blocks: allocator for raw disk blocks.
+//   + Log: crash recovery for multi-step updates.
+//   + Files: inode allocator, reading, writing, metadata.
+//   + Directories: inode with special contents (list of other inodes!)
+//   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
+//
+// This file contains the low-level file system manipulation
+// routines.  The (higher-level) system call implementations
+// are in sysfile.c.
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "stat.h"
+#include "mmu.h"
+#include "proc.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "buf.h"
+#include "file.h"
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+static void itrunc(struct inode*);
+// there should be one superblock per disk device, but we run with
+// only one device
+struct superblock sb; 
+
+// Read the super block.
+void
+readsb(int dev, struct superblock *sb)
+{
+  struct buf *bp;
+
+  bp = bread(dev, 1);
+  memmove(sb, bp->data, sizeof(*sb));
+  brelse(bp);
+}
+
+// Zero a block.
+static void
+bzero(int dev, int bno)
+{
+  struct buf *bp;
+
+  bp = bread(dev, bno);
+  memset(bp->data, 0, BSIZE);
+  log_write(bp);
+  brelse(bp);
+}
+
+// Blocks.
+
+// Allocate a zeroed disk block.
+static uint
+balloc(uint dev)
+{
+  int b, bi, m;
+  struct buf *bp;
+
+  bp = 0;
+  for(b = 0; b < sb.size; b += BPB){
+    bp = bread(dev, BBLOCK(b, sb));
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+      m = 1 << (bi % 8);
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+        bp->data[bi/8] |= m;  // Mark block in use.
+        log_write(bp);
+        brelse(bp);
+        bzero(dev, b + bi);
+        return b + bi;
+      }
+    }
+    brelse(bp);
+  }
+  panic("balloc: out of blocks");
+}
+
+// Free a disk block.
+static void
+bfree(int dev, uint b)
+{
+  struct buf *bp;
+  int bi, m;
+
+  bp = bread(dev, BBLOCK(b, sb));
+  bi = b % BPB;
+  m = 1 << (bi % 8);
+  if((bp->data[bi/8] & m) == 0)
+    panic("freeing free block");
+  bp->data[bi/8] &= ~m;
+  log_write(bp);
+  brelse(bp);
+}
+
+// Inodes.
+//
+// An inode describes a single unnamed file.
+// The inode disk structure holds metadata: the file's type,
+// its size, the number of links referring to it, and the
+// list of blocks holding the file's content.
+//
+// The inodes are laid out sequentially on disk at
+// sb.startinode. Each inode has a number, indicating its
+// position on the disk.
+//
+// The kernel keeps a cache of in-use inodes in memory
+// to provide a place for synchronizing access
+// to inodes used by multiple processes. The cached
+// inodes include book-keeping information that is
+// not stored on disk: ip->ref and ip->valid.
+//
+// An inode and its in-memory representation go through a
+// sequence of states before they can be used by the
+// rest of the file system code.
+//
+// * Allocation: an inode is allocated if its type (on disk)
+//   is non-zero. ialloc() allocates, and iput() frees if
+//   the reference and link counts have fallen to zero.
+//
+// * Referencing in cache: an entry in the inode cache
+//   is free if ip->ref is zero. Otherwise ip->ref tracks
+//   the number of in-memory pointers to the entry (open
+//   files and current directories). iget() finds or
+//   creates a cache entry and increments its ref; iput()
+//   decrements ref.
+//
+// * Valid: the information (type, size, &c) in an inode
+//   cache entry is only correct when ip->valid is 1.
+//   ilock() reads the inode from
+//   the disk and sets ip->valid, while iput() clears
+//   ip->valid if ip->ref has fallen to zero.
+//
+// * Locked: file system code may only examine and modify
+//   the information in an inode and its content if it
+//   has first locked the inode.
+//
+// Thus a typical sequence is:
+//   ip = iget(dev, inum)
+//   ilock(ip)
+//   ... examine and modify ip->xxx ...
+//   iunlock(ip)
+//   iput(ip)
+//
+// ilock() is separate from iget() so that system calls can
+// get a long-term reference to an inode (as for an open file)
+// and only lock it for short periods (e.g., in read()).
+// The separation also helps avoid deadlock and races during
+// pathname lookup. iget() increments ip->ref so that the inode
+// stays cached and pointers to it remain valid.
+//
+// Many internal file system functions expect the caller to
+// have locked the inodes involved; this lets callers create
+// multi-step atomic operations.
+//
+// The icache.lock spin-lock protects the allocation of icache
+// entries. Since ip->ref indicates whether an entry is free,
+// and ip->dev and ip->inum indicate which i-node an entry
+// holds, one must hold icache.lock while using any of those fields.
+//
+// An ip->lock sleep-lock protects all ip-> fields other than ref,
+// dev, and inum.  One must hold ip->lock in order to
+// read or write that inode's ip->valid, ip->size, ip->type, &c.
+
+struct {
+  struct spinlock lock;
+  struct inode inode[NINODE];
+} icache;
+
+void
+iinit(int dev)
+{
+  int i = 0;
+  
+  initlock(&icache.lock, "icache");
+  for(i = 0; i < NINODE; i++) {
+    initsleeplock(&icache.inode[i].lock, "inode");
+  }
+
+  readsb(dev, &sb);
+  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
+ inodestart %d bmap start %d\n", sb.size, sb.nblocks,
+          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
+          sb.bmapstart);
+}
+
+static struct inode* iget(uint dev, uint inum);
+
+//PAGEBREAK!
+// Allocate an inode on device dev.
+// Mark it as allocated by  giving it type type.
+// Returns an unlocked but allocated and referenced inode.
+struct inode*
+ialloc(uint dev, short type)
+{
+  int inum;
+  struct buf *bp;
+  struct dinode *dip;
+
+  for(inum = 1; inum < sb.ninodes; inum++){
+    bp = bread(dev, IBLOCK(inum, sb));
+    dip = (struct dinode*)bp->data + inum%IPB;
+    if(dip->type == 0){  // a free inode
+      memset(dip, 0, sizeof(*dip));
+      dip->type = type;
+      log_write(bp);   // mark it allocated on the disk
+      brelse(bp);
+      return iget(dev, inum);
+    }
+    brelse(bp);
+  }
+  panic("ialloc: no inodes");
+}
+
+// Copy a modified in-memory inode to disk.
+// Must be called after every change to an ip->xxx field
+// that lives on disk, since i-node cache is write-through.
+// Caller must hold ip->lock.
+void
+iupdate(struct inode *ip)
+{
+  struct buf *bp;
+  struct dinode *dip;
+
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+  dip = (struct dinode*)bp->data + ip->inum%IPB;
+  dip->type = ip->type;
+  dip->major = ip->major;
+  dip->minor = ip->minor;
+  dip->nlink = ip->nlink;
+  dip->size = ip->size;
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+  log_write(bp);
+  brelse(bp);
+}
+
+// Find the inode with number inum on device dev
+// and return the in-memory copy. Does not lock
+// the inode and does not read it from disk.
+static struct inode*
+iget(uint dev, uint inum)
+{
+  struct inode *ip, *empty;
+
+  acquire(&icache.lock);
+
+  // Is the inode already cached?
+  empty = 0;
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+      ip->ref++;
+      release(&icache.lock);
+      return ip;
+    }
+    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+      empty = ip;
+  }
+
+  // Recycle an inode cache entry.
+  if(empty == 0)
+    panic("iget: no inodes");
+
+  ip = empty;
+  ip->dev = dev;
+  ip->inum = inum;
+  ip->ref = 1;
+  ip->valid = 0;
+  release(&icache.lock);
+
+  return ip;
+}
+
+// Increment reference count for ip.
+// Returns ip to enable ip = idup(ip1) idiom.
+struct inode*
+idup(struct inode *ip)
+{
+  acquire(&icache.lock);
+  ip->ref++;
+  release(&icache.lock);
+  return ip;
+}
+
+// Lock the given inode.
+// Reads the inode from disk if necessary.
+void
+ilock(struct inode *ip)
+{
+  struct buf *bp;
+  struct dinode *dip;
+
+  if(ip == 0 || ip->ref < 1)
+    panic("ilock");
+
+  acquiresleep(&ip->lock);
+
+  if(ip->valid == 0){
+    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+    dip = (struct dinode*)bp->data + ip->inum%IPB;
+    ip->type = dip->type;
+    ip->major = dip->major;
+    ip->minor = dip->minor;
+    ip->nlink = dip->nlink;
+    ip->size = dip->size;
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+    brelse(bp);
+    ip->valid = 1;
+    if(ip->type == 0)
+      panic("ilock: no type");
+  }
+}
+
+// Unlock the given inode.
+void
+iunlock(struct inode *ip)
+{
+  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+    panic("iunlock");
+
+  releasesleep(&ip->lock);
+}
+
+// Drop a reference to an in-memory inode.
+// If that was the last reference, the inode cache entry can
+// be recycled.
+// If that was the last reference and the inode has no links
+// to it, free the inode (and its content) on disk.
+// All calls to iput() must be inside a transaction in
+// case it has to free the inode.
+void
+iput(struct inode *ip)
+{
+  acquiresleep(&ip->lock);
+  if(ip->valid && ip->nlink == 0){
+    acquire(&icache.lock);
+    int r = ip->ref;
+    release(&icache.lock);
+    if(r == 1){
+      // inode has no links and no other references: truncate and free.
+      itrunc(ip);
+      ip->type = 0;
+      iupdate(ip);
+      ip->valid = 0;
+    }
+  }
+  releasesleep(&ip->lock);
+
+  acquire(&icache.lock);
+  ip->ref--;
+  release(&icache.lock);
+}
+
+// Common idiom: unlock, then put.
+void
+iunlockput(struct inode *ip)
+{
+  iunlock(ip);
+  iput(ip);
+}
+
+//PAGEBREAK!
+// Inode content
+//
+// The content (data) associated with each inode is stored
+// in blocks on the disk. The first NDIRECT block numbers
+// are listed in ip->addrs[].  The next NINDIRECT blocks are
+// listed in block ip->addrs[NDIRECT].
+
+// Return the disk block address of the nth block in inode ip.
+// If there is no such block, bmap allocates one.
+static uint
+bmap(struct inode *ip, uint bn)
+{
+  uint addr, *a;
+  struct buf *bp;
+
+  if(bn < NDIRECT){
+    if((addr = ip->addrs[bn]) == 0)
+      ip->addrs[bn] = addr = balloc(ip->dev);
+    return addr;
+  }
+  bn -= NDIRECT;
+
+  if(bn < NINDIRECT){
+    // Load indirect block, allocating if necessary.
+    if((addr = ip->addrs[NDIRECT]) == 0)
+      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+    bp = bread(ip->dev, addr);
+    a = (uint*)bp->data;
+    if((addr = a[bn]) == 0){
+      a[bn] = addr = balloc(ip->dev);
+      log_write(bp);
+    }
+    brelse(bp);
+    return addr;
+  }
+
+  panic("bmap: out of range");
+}
+
+// Truncate inode (discard contents).
+// Only called when the inode has no links
+// to it (no directory entries referring to it)
+// and has no in-memory reference to it (is
+// not an open file or current directory).
+static void
+itrunc(struct inode *ip)
+{
+  int i, j;
+  struct buf *bp;
+  uint *a;
+
+  for(i = 0; i < NDIRECT; i++){
+    if(ip->addrs[i]){
+      bfree(ip->dev, ip->addrs[i]);
+      ip->addrs[i] = 0;
+    }
+  }
+
+  if(ip->addrs[NDIRECT]){
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+    a = (uint*)bp->data;
+    for(j = 0; j < NINDIRECT; j++){
+      if(a[j])
+        bfree(ip->dev, a[j]);
+    }
+    brelse(bp);
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+    ip->addrs[NDIRECT] = 0;
+  }
+
+  ip->size = 0;
+  iupdate(ip);
+}
+
+// Copy stat information from inode.
+// Caller must hold ip->lock.
+void
+stati(struct inode *ip, struct stat *st)
+{
+  st->dev = ip->dev;
+  st->ino = ip->inum;
+  st->type = ip->type;
+  st->nlink = ip->nlink;
+  st->size = ip->size;
+}
+
+//PAGEBREAK!
+// Read data from inode.
+// Caller must hold ip->lock.
+int
+readi(struct inode *ip, char *dst, uint off, uint n)
+{
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+      return -1;
+    return devsw[ip->major].read(ip, dst, n);
+  }
+
+  if(off > ip->size || off + n < off)
+    return -1;
+  if(off + n > ip->size)
+    n = ip->size - off;
+
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+    m = min(n - tot, BSIZE - off%BSIZE);
+    memmove(dst, bp->data + off%BSIZE, m);
+    brelse(bp);
+  }
+  return n;
+}
+
+// PAGEBREAK!
+// Write data to inode.
+// Caller must hold ip->lock.
+int
+writei(struct inode *ip, char *src, uint off, uint n)
+{
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+      return -1;
+    return devsw[ip->major].write(ip, src, n);
+  }
+
+  if(off > ip->size || off + n < off)
+    return -1;
+  if(off + n > MAXFILE*BSIZE)
+    return -1;
+
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+    m = min(n - tot, BSIZE - off%BSIZE);
+    memmove(bp->data + off%BSIZE, src, m);
+    log_write(bp);
+    brelse(bp);
+  }
+
+  if(n > 0 && off > ip->size){
+    ip->size = off;
+    iupdate(ip);
+  }
+  return n;
+}
+
+//PAGEBREAK!
+// Directories
+
+int
+namecmp(const char *s, const char *t)
+{
+  return strncmp(s, t, DIRSIZ);
+}
+
+// Look for a directory entry in a directory.
+// If found, set *poff to byte offset of entry.
+struct inode*
+dirlookup(struct inode *dp, char *name, uint *poff)
+{
+  uint off, inum;
+  struct dirent de;
+
+  if(dp->type != T_DIR)
+    panic("dirlookup not DIR");
+
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("dirlookup read");
+    if(de.inum == 0)
+      continue;
+    if(namecmp(name, de.name) == 0){
+      // entry matches path element
+      if(poff)
+        *poff = off;
+      inum = de.inum;
+      return iget(dp->dev, inum);
+    }
+  }
+
+  return 0;
+}
+
+// Write a new directory entry (name, inum) into the directory dp.
+int
+dirlink(struct inode *dp, char *name, uint inum)
+{
+  int off;
+  struct dirent de;
+  struct inode *ip;
+
+  // Check that name is not present.
+  if((ip = dirlookup(dp, name, 0)) != 0){
+    iput(ip);
+    return -1;
+  }
+
+  // Look for an empty dirent.
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("dirlink read");
+    if(de.inum == 0)
+      break;
+  }
+
+  strncpy(de.name, name, DIRSIZ);
+  de.inum = inum;
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+    panic("dirlink");
+
+  return 0;
+}
+
+//PAGEBREAK!
+// Paths
+
+// Copy the next path element from path into name.
+// Return a pointer to the element following the copied one.
+// The returned path has no leading slashes,
+// so the caller can check *path=='\0' to see if the name is the last one.
+// If no name to remove, return 0.
+//
+// Examples:
+//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
+//   skipelem("///a//bb", name) = "bb", setting name = "a"
+//   skipelem("a", name) = "", setting name = "a"
+//   skipelem("", name) = skipelem("////", name) = 0
+//
+static char*
+skipelem(char *path, char *name)
+{
+  char *s;
+  int len;
+
+  while(*path == '/')
+    path++;
+  if(*path == 0)
+    return 0;
+  s = path;
+  while(*path != '/' && *path != 0)
+    path++;
+  len = path - s;
+  if(len >= DIRSIZ)
+    memmove(name, s, DIRSIZ);
+  else {
+    memmove(name, s, len);
+    name[len] = 0;
+  }
+  while(*path == '/')
+    path++;
+  return path;
+}
+
+// Look up and return the inode for a path name.
+// If parent != 0, return the inode for the parent and copy the final
+// path element into name, which must have room for DIRSIZ bytes.
+// Must be called inside a transaction since it calls iput().
+static struct inode*
+namex(char *path, int nameiparent, char *name)
+{
+  struct inode *ip, *next;
+
+  if(*path == '/')
+    ip = iget(ROOTDEV, ROOTINO);
+  else
+    ip = idup(myproc()->cwd);
+
+  while((path = skipelem(path, name)) != 0){
+    ilock(ip);
+    if(ip->type != T_DIR){
+      iunlockput(ip);
+      return 0;
+    }
+    if(nameiparent && *path == '\0'){
+      // Stop one level early.
+      iunlock(ip);
+      return ip;
+    }
+    if((next = dirlookup(ip, name, 0)) == 0){
+      iunlockput(ip);
+      return 0;
+    }
+    iunlockput(ip);
+    ip = next;
+  }
+  if(nameiparent){
+    iput(ip);
+    return 0;
+  }
+  return ip;
+}
+
+struct inode*
+namei(char *path)
+{
+  char name[DIRSIZ];
+  return namex(path, 0, name);
+}
+
+struct inode*
+nameiparent(char *path, char *name)
+{
+  return namex(path, 1, name);
+}
diff --git a/mmu.h b/mmu.h
index a82d8e2..f31ffff 100644
--- a/mmu.h
+++ b/mmu.h
@@ -95,6 +95,9 @@ struct segdesc {
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
 #define PTE_PS          0x080   // Page Size
+#define PTE_A           0x020   // Accessed
+#define PTE_PG          0x200   // Paged out to secondary storage
+#define PTE_D           0x040  // Dirty
 
 // Address in page table or page directory entry
 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
diff --git a/paging.patch b/paging.patch
new file mode 100644
index 0000000..54ef2b9
--- /dev/null
+++ b/paging.patch
@@ -0,0 +1,225 @@
+diff --git a/defs.h b/defs.h
+index 82fb982..f33f2cb 100644
+--- a/defs.h
++++ b/defs.h
+@@ -52,6 +52,11 @@ struct inode*   nameiparent(char*, char*);
+ int             readi(struct inode*, char*, uint, uint);
+ void            stati(struct inode*, struct stat*);
+ int             writei(struct inode*, char*, uint, uint);
++int             createSwapFile(struct proc* p);
++int             readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size);
++int             writeToSwapFile(struct proc* p, char* buffer, uint placeOnFile, uint size);
++int             removeSwapFile(struct proc* p);
++
+ 
+ // ide.c
+ void            ideinit(void);
+@@ -124,6 +129,11 @@ void            yield(void);
+ // swtch.S
+ void            swtch(struct context**, struct context*);
+ 
++// sysfile
++struct inode*   create(char *path, short type, short major, short minor);
++int             isdirempty(struct inode *dp);
++
++
+ // spinlock.c
+ void            acquire(struct spinlock*);
+ void            getcallerpcs(void*, uint*);
+diff --git a/fs.c b/fs.c
+index feb59fe..f7c92cf 100644
+--- a/fs.c
++++ b/fs.c
+@@ -669,3 +669,144 @@ nameiparent(char *path, char *name)
+ {
+   return namex(path, 1, name);
+ }
++
++// NEW FOR PAGING
++
++#include "fcntl.h"
++#define DIGITS 14
++
++char* itoa(int i, char b[]){
++    char const digit[] = "0123456789";
++    char* p = b;
++    if(i<0){
++        *p++ = '-';
++        i *= -1;
++    }
++    int shifter = i;
++    do{ //Move to where representation ends
++        ++p;
++        shifter = shifter/10;
++    }while(shifter);
++    *p = '\0';
++    do{ //Move back, inserting digits as u go
++        *--p = digit[i%10];
++        i = i/10;
++    }while(i);
++    return b;
++}
++
++//remove swap file of proc p;
++int
++removeSwapFile(struct proc* p)
++{
++	//path of proccess
++	char path[DIGITS];
++	memmove(path,"/.swap", 6);
++	itoa(p->pid, path+ 6);
++
++	struct inode *ip, *dp;
++	struct dirent de;
++	char name[DIRSIZ];
++	uint off;
++
++	if(0 == p->swapFile)
++	{
++		return -1;
++	}
++	fileclose(p->swapFile);
++
++	begin_op();
++	if((dp = nameiparent(path, name)) == 0)
++	{
++		end_op();
++		return -1;
++	}
++
++	ilock(dp);
++
++	  // Cannot unlink "." or "..".
++	if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
++	   goto bad;
++
++	if((ip = dirlookup(dp, name, &off)) == 0)
++		goto bad;
++	ilock(ip);
++
++	if(ip->nlink < 1)
++		panic("unlink: nlink < 1");
++	if(ip->type == T_DIR && !isdirempty(ip)){
++		iunlockput(ip);
++		goto bad;
++	}
++
++	memset(&de, 0, sizeof(de));
++	if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
++		panic("unlink: writei");
++	if(ip->type == T_DIR){
++		dp->nlink--;
++		iupdate(dp);
++	}
++	iunlockput(dp);
++
++	ip->nlink--;
++	iupdate(ip);
++	iunlockput(ip);
++
++	end_op();
++
++	return 0;
++
++	bad:
++		iunlockput(dp);
++		end_op();
++		return -1;
++
++}
++
++
++//return 0 on success
++int
++createSwapFile(struct proc* p)
++{
++
++	char path[DIGITS];
++	memmove(path,"/.swap", 6);
++	itoa(p->pid, path+ 6);
++
++    begin_op();
++    struct inode * in = create(path, T_FILE, 0, 0);
++	iunlock(in);
++
++	p->swapFile = filealloc();
++	if (p->swapFile == 0)
++		panic("no slot for files on /store");
++
++	p->swapFile->ip = in;
++	p->swapFile->type = FD_INODE;
++	p->swapFile->off = 0;
++	p->swapFile->readable = O_WRONLY;
++	p->swapFile->writable = O_RDWR;
++    end_op();
++
++    return 0;
++}
++
++//return as sys_write (-1 when error)
++int
++writeToSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
++{
++	p->swapFile->off = placeOnFile;
++
++	return filewrite(p->swapFile, buffer, size);
++
++}
++
++//return as sys_read (-1 when error)
++int
++readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
++{
++	p->swapFile->off = placeOnFile;
++
++	return fileread(p->swapFile, buffer,  size);
++}
++
+diff --git a/mmu.h b/mmu.h
+index a82d8e2..aec4420 100644
+--- a/mmu.h
++++ b/mmu.h
+@@ -95,6 +95,8 @@ struct segdesc {
+ #define PTE_W           0x002   // Writeable
+ #define PTE_U           0x004   // User
+ #define PTE_PS          0x080   // Page Size
++#define PTE_A           0x020   // Accessed
++#define PTE_PG          0x200   // Paged out to secondary storage
+ 
+ // Address in page table or page directory entry
+ #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
+diff --git a/proc.h b/proc.h
+index 1647114..9f65fae 100644
+--- a/proc.h
++++ b/proc.h
+@@ -49,6 +49,8 @@ struct proc {
+   struct file *ofile[NOFILE];  // Open files
+   struct inode *cwd;           // Current directory
+   char name[16];               // Process name (debugging)
++  //Swap file. must initiate with create swap file
++  struct file *swapFile;			//page file
+ };
+ 
+ // Process memory is laid out contiguously, low addresses first:
+diff --git a/sysfile.c b/sysfile.c
+index 87e508b..22d3588 100644
+--- a/sysfile.c
++++ b/sysfile.c
+@@ -165,7 +165,7 @@ bad:
+ }
+ 
+ // Is the directory dp empty except for "." and ".." ?
+-static int
++int
+ isdirempty(struct inode *dp)
+ {
+   int off;
+@@ -238,7 +238,7 @@ bad:
+   return -1;
+ }
+ 
+-static struct inode*
++struct inode*
+ create(char *path, short type, short major, short minor)
+ {
+   uint off;
diff --git a/proc.c b/proc.c
index 806b1b1..f913429 100644
--- a/proc.c
+++ b/proc.c
@@ -6,6 +6,7 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "fs.h"
 
 struct {
   struct spinlock lock;
@@ -74,7 +75,7 @@ static struct proc*
 allocproc(void)
 {
   struct proc *p;
-  char *sp;
+  char *sp; int i;
 
   acquire(&ptable.lock);
 
@@ -112,6 +113,47 @@ found:
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
+  // add new variables for swapping
+  p->head = 0;
+  p->tail = 0;
+  p->no_of_mem_pages = 0;
+  p->no_of_swap_pages = 0;
+  
+  struct file_offsets* temp;
+  // all file offsets are free
+  for(i=0; i<MAX_SWAP_PAGES; i++){
+    // create new struct
+    p->file_values[i].index = i;
+    p->file_values[i].next = 0;
+    if(i!=0) temp->next = &p->file_values[i];
+    else p->free_file_pos = &p->file_values[i]; // if first element
+    temp = &p->file_values[i];
+    // cprintf("Inserting hole value %d\n", temp->index);
+    // cprintf("head holes list : %d\n", p->free_file_pos->index);
+  }
+
+  // sanity check
+  // temp = p->free_file_pos;
+  // cprintf("head holes list : %d\n", p->free_file_pos->index);
+  // while(temp->next != 0){
+  //   cprintf("%d ->", temp->index);
+  //   temp = temp->next;
+  // }
+  // cprintf("\n");
+
+  if(p->pid > 2) createSwapFile(p);
+  
+  for(i=0; i<MAX_TOTAL_PAGES; i++){
+    p->all_pages[i].va = -1;
+    p->all_pages[i].pgdir = 0;
+    p->all_pages[i].next = 0;
+    p->all_pages[i].prev = 0;
+    p->all_pages[i].file_index = -1;
+    p->all_pages[i].index = -1;  // change this to correct position when allocated
+  }
+
+  p->no_of_page_faults = 0;
+
   return p;
 }
 
@@ -188,6 +230,11 @@ fork(void)
   if((np = allocproc()) == 0){
     return -1;
   }
+  
+  #if PRINT 
+    cprintf("In fork, parent id %d and child id %d\n", curproc->pid, np->pid); 
+  #endif
+  
 
   // Copy process state from proc.
   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
@@ -200,6 +247,80 @@ fork(void)
   np->parent = curproc;
   *np->tf = *curproc->tf;
 
+
+  /*
+    here shell is forked from init
+    and others are forked from shell?
+
+    so need all to get the info too .. and only page when pid > 2
+  */
+
+  // add new variables for swapping
+  if(curproc->pid > 2)
+  {
+    // np->head = curproc->head;
+    // np->tail = curproc->tail;
+    np->no_of_mem_pages = curproc->no_of_mem_pages;
+    np->no_of_swap_pages = curproc->no_of_swap_pages;
+    // np->free_file_pos = curproc->free_file_pos; // TODO : do i need to reallocate
+
+    // copy struct file_offsets
+    for(i=0; i<MAX_SWAP_PAGES; i++) {
+      np->file_values[i].index = curproc->file_values[i].index;
+      if(curproc->file_values[i].next == 0) np->file_values[i].next = 0;
+      else np->file_values[i].next = &np->file_values[curproc->file_values[i].next->index];
+
+      // set head
+      if(np->file_values[i].index == curproc->free_file_pos->index) np->free_file_pos =  &np->file_values[i];
+    }
+
+    // also create and copy file?
+    createSwapFile(np); // create swap file
+
+    // int frac = 2;
+    char buffer[PGSIZE/2];
+    int read_count=0, offset=0;
+    
+    while(1)
+    {
+      read_count = readFromSwapFile(curproc, buffer, offset*PGSIZE/2, PGSIZE/2);
+      if(read_count == 0) break;
+      writeToSwapFile(np, buffer, offset*PGSIZE/2, PGSIZE/2);
+      memset(buffer, 0, PGSIZE/2);
+      offset += 1;
+    }
+
+
+
+    // cprintf("File created\n");
+    for(i=0; i<MAX_TOTAL_PAGES; i++){
+      // cprintf("Considering : %d -> %d\n", i, curproc->all_pages[i].index);
+      np->all_pages[i].va = curproc->all_pages[i].va;
+      // cprintf("#### IN FORK -> pid is %d, pid pgdir is %d, index is %d\n", np->pid, *np->pgdir, curproc->all_pages[i].file_index);
+      if(curproc->all_pages[i].index == -1) np->all_pages[i].pgdir = 0;
+      else np->all_pages[i].pgdir = np->pgdir;
+
+      if(curproc->all_pages[i].next == 0) np->all_pages[i].next = 0;
+      else np->all_pages[i].next = &np->all_pages[curproc->all_pages[i].next->index];
+
+      if(curproc->all_pages[i].prev == 0) np->all_pages[i].prev = 0;
+      else np->all_pages[i].prev = &np->all_pages[curproc->all_pages[i].prev->index];
+
+      // np->all_pages[i].next = curproc->all_pages[i].next;
+      // np->all_pages[i].prev = curproc->all_pages[i].prev;
+      np->all_pages[i].file_index = curproc->all_pages[i].file_index;
+      np->all_pages[i].index = curproc->all_pages[i].index;  // change this to correct position when allocated
+
+      // copy head and tail
+      if(curproc->all_pages[i].index == curproc->head->index) np->head = &np->all_pages[i];
+      if(curproc->all_pages[i].index == curproc->tail->index) np->tail = &np->all_pages[i];
+    }
+    np->no_of_page_faults = curproc->no_of_page_faults;
+    // cprintf("Finished copying indexes\n");
+
+    // lcr3(V2P(np->pgdir));
+  }
+
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
@@ -231,9 +352,16 @@ exit(void)
   struct proc *p;
   int fd;
 
+  cprintf("All processe details. EXITING..\n");
+  procdump();
+  // print_proc_info(curproc);
+  
   if(curproc == initproc)
     panic("init exiting");
 
+  // delete swap files
+  if(curproc->pid > 2) removeSwapFile(curproc);
+
   // Close all open files.
   for(fd = 0; fd < NOFILE; fd++){
     if(curproc->ofile[fd]){
@@ -530,5 +658,116 @@ procdump(void)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
+
+    /// see mappages and walkpgdir - https://www.youtube.com/watch?v=8V2YkO7lfvs
+    printPTE(p->pgdir, p->sz);
   }
 }
+
+
+void
+clearAccessBitForAll(void)
+{
+  struct proc *p;
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED) continue;
+    clearAccessBit(p);
+  }
+}
+
+
+// queue functionalities
+void 
+enqueue_page(struct proc* cur_proc, struct page_struct* page)
+{
+  page->next = cur_proc->head;
+  page->prev = 0;
+  // if there is a head
+  if(cur_proc->head != 0) cur_proc->head->prev = page;
+  else cur_proc->tail = page;
+  cur_proc->head = page;
+  // cprintf("enqueue head va : %d, and index %d\n", page->va, page->index);
+}
+
+struct page_struct*
+dequeue_page(struct proc* cur_proc)
+{
+  int MODE = 0;
+  #if FIFO
+    MODE = 0; // 0 for FIFO, 1 for NRU
+  #endif
+
+  #if NRU
+    MODE = 1;
+  #endif
+
+  if(cur_proc->tail == 0){
+    panic("No element left in queue"); return 0;
+  }
+
+
+  // REMEMBER : dont free the dequeued memory
+  struct page_struct* temp = cur_proc->tail;
+
+  if(MODE == 0){
+    cur_proc->tail = temp->prev;
+    temp->prev = 0; temp->next=0;
+    if(cur_proc->tail == 0) cur_proc->head = 0; // nothing is left
+    else cur_proc->tail->next = 0;
+    // cprintf("dequeue head va : %d, and index %d\n", temp->va, temp->index);
+    return temp;
+  }
+
+  else if(MODE == 1){
+    temp = get_NRU_page(cur_proc);
+    // TODO : do separation logic
+    // remove this from linklist
+    if (temp->prev != 0) temp->prev->next = temp->next;
+    if (temp->next != 0) temp->next->prev = temp->prev;
+    // configure head and tail
+    if(temp->prev == 0) cur_proc->head = temp->next;
+    if(temp->next == 0) cur_proc->tail = temp->prev;
+    // cprintf("from NRU : page index %d, va %d, pgdir %d\n", temp->index, temp->va, *temp->pgdir);
+    return temp;
+  }
+  else return 0;
+}
+
+
+// struct page_struct array functions
+int
+get_free_index(struct proc* cur_proc)
+{
+  int i;
+  for(i=0; i<MAX_TOTAL_PAGES; i++)
+  {
+    if(cur_proc->all_pages[i].index == -1){
+      cur_proc->all_pages[i].index = i; // set index
+      return i;
+    }
+  }
+  return -1; // this means no free pages
+}
+
+
+// struct file_offsets functions
+// stores hole locations
+void
+push_file_offsets(struct proc* cur_proc, int n)
+{
+  cur_proc->file_values[n].next = cur_proc->free_file_pos;
+  cur_proc->free_file_pos = &cur_proc->file_values[n];
+}
+
+int
+pop_file_offsets(struct proc* cur_proc)
+{
+  struct file_offsets* temp;
+  temp = cur_proc->free_file_pos;
+  int index = temp->index;
+  // cprintf("popping file offset index %d\n", index);
+  cur_proc->free_file_pos = temp->next;
+  temp->next = 0; // clear next 
+  return index;
+}
\ No newline at end of file
diff --git a/proc.h b/proc.h
index 1647114..b5cd706 100644
--- a/proc.h
+++ b/proc.h
@@ -34,6 +34,30 @@ struct context {
 
 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
+// For storing pages
+#define MAX_PSYC_PAGES 15
+#define MAX_TOTAL_PAGES 30
+#define MAX_SWAP_PAGES (MAX_TOTAL_PAGES - MAX_PSYC_PAGES)
+
+// to keep track of page metadata
+struct page_struct
+{
+  uint va;
+  pde_t* pgdir;
+  struct page_struct* next;
+  struct page_struct* prev;
+  int file_index; // if -1 then not in file, else in file. file_index*PGSIZE gives offset
+  int index; // index in array -> // change this to correct position when allocated
+};
+
+
+// to keep track of file holes
+struct file_offsets
+{
+  int index;
+  struct file_offsets* next;
+};
+
 // Per-process state
 struct proc {
   uint sz;                     // Size of process memory (bytes)
@@ -49,6 +73,24 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  //Swap file. must initiate with create swap file
+  struct file *swapFile;			//page file
+
+  // for swapping files custom attributes
+  // keep track of pages in memory. most recent at head and least recent at tail
+  struct page_struct* head;
+  struct page_struct* tail;
+  struct page_struct all_pages[MAX_TOTAL_PAGES];
+
+  struct file_offsets file_values[MAX_SWAP_PAGES];
+  struct file_offsets* free_file_pos;
+
+  int no_of_mem_pages;
+  int no_of_swap_pages;
+
+  // need stuff for NRU
+
+  int no_of_page_faults;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..916f66e 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,8 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+// custom
+extern int sys_procdetails(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +128,7 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_procdetails] sys_procdetails,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..fb99db9 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+
+// custom
+#define SYS_procdetails 22
diff --git a/sysfile.c b/sysfile.c
index bfe61b7..bf3848e 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -165,7 +165,7 @@ bad:
 }
 
 // Is the directory dp empty except for "." and ".." ?
-static int
+int
 isdirempty(struct inode *dp)
 {
   int off;
@@ -238,7 +238,7 @@ bad:
   return -1;
 }
 
-static struct inode*
+struct inode*
 create(char *path, short type, short major, short minor)
 {
   struct inode *ip, *dp;
diff --git a/sysfile.c.orig b/sysfile.c.orig
new file mode 100644
index 0000000..bfe61b7
--- /dev/null
+++ b/sysfile.c.orig
@@ -0,0 +1,444 @@
+//
+// File-system system calls.
+// Mostly argument checking, since we don't trust
+// user code, and calls into file.c and fs.c.
+//
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "stat.h"
+#include "mmu.h"
+#include "proc.h"
+#include "fs.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "file.h"
+#include "fcntl.h"
+
+// Fetch the nth word-sized system call argument as a file descriptor
+// and return both the descriptor and the corresponding struct file.
+static int
+argfd(int n, int *pfd, struct file **pf)
+{
+  int fd;
+  struct file *f;
+
+  if(argint(n, &fd) < 0)
+    return -1;
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+    return -1;
+  if(pfd)
+    *pfd = fd;
+  if(pf)
+    *pf = f;
+  return 0;
+}
+
+// Allocate a file descriptor for the given file.
+// Takes over file reference from caller on success.
+static int
+fdalloc(struct file *f)
+{
+  int fd;
+  struct proc *curproc = myproc();
+
+  for(fd = 0; fd < NOFILE; fd++){
+    if(curproc->ofile[fd] == 0){
+      curproc->ofile[fd] = f;
+      return fd;
+    }
+  }
+  return -1;
+}
+
+int
+sys_dup(void)
+{
+  struct file *f;
+  int fd;
+
+  if(argfd(0, 0, &f) < 0)
+    return -1;
+  if((fd=fdalloc(f)) < 0)
+    return -1;
+  filedup(f);
+  return fd;
+}
+
+int
+sys_read(void)
+{
+  struct file *f;
+  int n;
+  char *p;
+
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+    return -1;
+  return fileread(f, p, n);
+}
+
+int
+sys_write(void)
+{
+  struct file *f;
+  int n;
+  char *p;
+
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+    return -1;
+  return filewrite(f, p, n);
+}
+
+int
+sys_close(void)
+{
+  int fd;
+  struct file *f;
+
+  if(argfd(0, &fd, &f) < 0)
+    return -1;
+  myproc()->ofile[fd] = 0;
+  fileclose(f);
+  return 0;
+}
+
+int
+sys_fstat(void)
+{
+  struct file *f;
+  struct stat *st;
+
+  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+    return -1;
+  return filestat(f, st);
+}
+
+// Create the path new as a link to the same inode as old.
+int
+sys_link(void)
+{
+  char name[DIRSIZ], *new, *old;
+  struct inode *dp, *ip;
+
+  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+    return -1;
+
+  begin_op();
+  if((ip = namei(old)) == 0){
+    end_op();
+    return -1;
+  }
+
+  ilock(ip);
+  if(ip->type == T_DIR){
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+
+  ip->nlink++;
+  iupdate(ip);
+  iunlock(ip);
+
+  if((dp = nameiparent(new, name)) == 0)
+    goto bad;
+  ilock(dp);
+  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+    iunlockput(dp);
+    goto bad;
+  }
+  iunlockput(dp);
+  iput(ip);
+
+  end_op();
+
+  return 0;
+
+bad:
+  ilock(ip);
+  ip->nlink--;
+  iupdate(ip);
+  iunlockput(ip);
+  end_op();
+  return -1;
+}
+
+// Is the directory dp empty except for "." and ".." ?
+static int
+isdirempty(struct inode *dp)
+{
+  int off;
+  struct dirent de;
+
+  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("isdirempty: readi");
+    if(de.inum != 0)
+      return 0;
+  }
+  return 1;
+}
+
+//PAGEBREAK!
+int
+sys_unlink(void)
+{
+  struct inode *ip, *dp;
+  struct dirent de;
+  char name[DIRSIZ], *path;
+  uint off;
+
+  if(argstr(0, &path) < 0)
+    return -1;
+
+  begin_op();
+  if((dp = nameiparent(path, name)) == 0){
+    end_op();
+    return -1;
+  }
+
+  ilock(dp);
+
+  // Cannot unlink "." or "..".
+  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+    goto bad;
+
+  if((ip = dirlookup(dp, name, &off)) == 0)
+    goto bad;
+  ilock(ip);
+
+  if(ip->nlink < 1)
+    panic("unlink: nlink < 1");
+  if(ip->type == T_DIR && !isdirempty(ip)){
+    iunlockput(ip);
+    goto bad;
+  }
+
+  memset(&de, 0, sizeof(de));
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+    panic("unlink: writei");
+  if(ip->type == T_DIR){
+    dp->nlink--;
+    iupdate(dp);
+  }
+  iunlockput(dp);
+
+  ip->nlink--;
+  iupdate(ip);
+  iunlockput(ip);
+
+  end_op();
+
+  return 0;
+
+bad:
+  iunlockput(dp);
+  end_op();
+  return -1;
+}
+
+static struct inode*
+create(char *path, short type, short major, short minor)
+{
+  struct inode *ip, *dp;
+  char name[DIRSIZ];
+
+  if((dp = nameiparent(path, name)) == 0)
+    return 0;
+  ilock(dp);
+
+  if((ip = dirlookup(dp, name, 0)) != 0){
+    iunlockput(dp);
+    ilock(ip);
+    if(type == T_FILE && ip->type == T_FILE)
+      return ip;
+    iunlockput(ip);
+    return 0;
+  }
+
+  if((ip = ialloc(dp->dev, type)) == 0)
+    panic("create: ialloc");
+
+  ilock(ip);
+  ip->major = major;
+  ip->minor = minor;
+  ip->nlink = 1;
+  iupdate(ip);
+
+  if(type == T_DIR){  // Create . and .. entries.
+    dp->nlink++;  // for ".."
+    iupdate(dp);
+    // No ip->nlink++ for ".": avoid cyclic ref count.
+    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+      panic("create dots");
+  }
+
+  if(dirlink(dp, name, ip->inum) < 0)
+    panic("create: dirlink");
+
+  iunlockput(dp);
+
+  return ip;
+}
+
+int
+sys_open(void)
+{
+  char *path;
+  int fd, omode;
+  struct file *f;
+  struct inode *ip;
+
+  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+    return -1;
+
+  begin_op();
+
+  if(omode & O_CREATE){
+    ip = create(path, T_FILE, 0, 0);
+    if(ip == 0){
+      end_op();
+      return -1;
+    }
+  } else {
+    if((ip = namei(path)) == 0){
+      end_op();
+      return -1;
+    }
+    ilock(ip);
+    if(ip->type == T_DIR && omode != O_RDONLY){
+      iunlockput(ip);
+      end_op();
+      return -1;
+    }
+  }
+
+  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+    if(f)
+      fileclose(f);
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+  end_op();
+
+  f->type = FD_INODE;
+  f->ip = ip;
+  f->off = 0;
+  f->readable = !(omode & O_WRONLY);
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+  return fd;
+}
+
+int
+sys_mkdir(void)
+{
+  char *path;
+  struct inode *ip;
+
+  begin_op();
+  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+  end_op();
+  return 0;
+}
+
+int
+sys_mknod(void)
+{
+  struct inode *ip;
+  char *path;
+  int major, minor;
+
+  begin_op();
+  if((argstr(0, &path)) < 0 ||
+     argint(1, &major) < 0 ||
+     argint(2, &minor) < 0 ||
+     (ip = create(path, T_DEV, major, minor)) == 0){
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+  end_op();
+  return 0;
+}
+
+int
+sys_chdir(void)
+{
+  char *path;
+  struct inode *ip;
+  struct proc *curproc = myproc();
+  
+  begin_op();
+  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
+    end_op();
+    return -1;
+  }
+  ilock(ip);
+  if(ip->type != T_DIR){
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+  iput(curproc->cwd);
+  end_op();
+  curproc->cwd = ip;
+  return 0;
+}
+
+int
+sys_exec(void)
+{
+  char *path, *argv[MAXARG];
+  int i;
+  uint uargv, uarg;
+
+  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+    return -1;
+  }
+  memset(argv, 0, sizeof(argv));
+  for(i=0;; i++){
+    if(i >= NELEM(argv))
+      return -1;
+    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
+      return -1;
+    if(uarg == 0){
+      argv[i] = 0;
+      break;
+    }
+    if(fetchstr(uarg, &argv[i]) < 0)
+      return -1;
+  }
+  return exec(path, argv);
+}
+
+int
+sys_pipe(void)
+{
+  int *fd;
+  struct file *rf, *wf;
+  int fd0, fd1;
+
+  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+    return -1;
+  if(pipealloc(&rf, &wf) < 0)
+    return -1;
+  fd0 = -1;
+  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+    if(fd0 >= 0)
+      myproc()->ofile[fd0] = 0;
+    fileclose(rf);
+    fileclose(wf);
+    return -1;
+  }
+  fd[0] = fd0;
+  fd[1] = fd1;
+  return 0;
+}
diff --git a/sysproc.c b/sysproc.c
index 0686d29..fd81500 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,12 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+// CUSTOM
+// get current process details
+int
+sys_procdetails(void)
+{
+  print_proc_info(myproc());
+  return 1;
+}
\ No newline at end of file
diff --git a/test_fork.c b/test_fork.c
new file mode 100644
index 0000000..0d0c101
--- /dev/null
+++ b/test_fork.c
@@ -0,0 +1,54 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+void test_fork()
+{
+    int no_of_int = (4096*17)/4; // as integer so required memory is 4 bytes
+    // int pid = fork();
+    int constant;
+    int missed_count = 0;
+    int* arr = malloc(no_of_int*sizeof(int));;
+    int pid = fork();
+
+
+    if(pid == 0){
+        sleep(10);
+        constant = 17;
+        printf(1, ">>Initial CHILD Process Details:\n");
+    }
+    else{
+        constant = 13;
+        printf(1, ">>Initial PARENT Process Details:\n");
+    }
+    procdetails();
+
+
+    for(int i=0; i<no_of_int; i++){
+        arr[i] = constant*i;
+    }
+    for(int i=0; i<no_of_int; i++){
+        if(arr[i] != constant*i) missed_count += 1;
+    }
+
+    sleep(60);
+    if(pid == 0){
+        printf(1, ">>After Calculations. CHILD Process Details:\n");
+    }
+    if(pid == 1){
+        printf(1, ">>After Calculations. PARENT Process Details:\n");
+    }
+    
+    procdetails();
+    printf(1, "Missed count : %d\n", missed_count);
+
+    free((void*)arr);
+    if(pid != 0) wait();
+}
+
+int
+main(int argc, char *argv[])
+{
+    test_fork();
+    exit();
+}
\ No newline at end of file
diff --git a/test_swap.c b/test_swap.c
new file mode 100644
index 0000000..a0e25f7
--- /dev/null
+++ b/test_swap.c
@@ -0,0 +1,53 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+void test_swap()
+{
+    int PGSIZE = 4096;
+    int MAX_PHYS = 15;
+    // int MAX_TOTAL = 30;
+    // test fifo / nru enqueue dequeue
+    printf(1, ">>Initial Process Details:\n");
+    procdetails();
+    // should already have 3 pages
+
+    char* pages[MAX_PHYS - 3]; // char array as 1 byte
+    // push to limit
+    int i;
+    for(i=0; i<(MAX_PHYS-3); i++)
+    {  
+        pages[i] = sbrk(PGSIZE);
+    }
+    pages[0][0] = 'N'; // setting a value for later check
+    pages[1][0] = 'Z'; 
+    printf(1, ">>After adding pages upto memory limit: Process Details:\n");
+    procdetails();
+    
+    // now push to swap file
+    sbrk(4*PGSIZE); // this should get the 4th page to memory which has pages[0][0]
+    printf(1, ">>After adding 4 pages to swap file: Process Details:\n");
+    procdetails();
+
+    // now retrieve a value
+    if(pages[0][0] == 'N') printf(1, ">>Successfully retrieved a value (Page fault in FIFO))\n");
+    else printf(1, ">>Not successful retrieval\n");
+    procdetails();
+
+    // now shrink memory
+    sbrk(-2*PGSIZE);
+    printf(1, ">>After shrinking 2 pages from memory: Process Details:\n");
+    procdetails();
+
+    // now retrieve a value
+    if(pages[1][0] == 'Z') printf(1, ">>Successfully retrieved a value (Page fault in FIFO))\n");
+    else printf(1, ">>Not successful retrieval\n");
+    procdetails();
+}
+
+int
+main(int argc, char *argv[])
+{
+    test_swap();
+    exit();
+}
\ No newline at end of file
diff --git a/trap.c b/trap.c
index 41c66eb..9d29943 100644
--- a/trap.c
+++ b/trap.c
@@ -36,6 +36,10 @@ idtinit(void)
 void
 trap(struct trapframe *tf)
 {
+
+  uint page_fault_va;
+  struct proc* curproc = myproc();
+
   if(tf->trapno == T_SYSCALL){
     if(myproc()->killed)
       exit();
@@ -46,6 +50,7 @@ trap(struct trapframe *tf)
     return;
   }
 
+  if((curproc != 0) && curproc->pid > 2) clearAccessBitForAll();
   switch(tf->trapno){
   case T_IRQ0 + IRQ_TIMER:
     if(cpuid() == 0){
@@ -55,6 +60,7 @@ trap(struct trapframe *tf)
       release(&tickslock);
     }
     lapiceoi();
+
     break;
   case T_IRQ0 + IRQ_IDE:
     ideintr();
@@ -78,6 +84,20 @@ trap(struct trapframe *tf)
     lapiceoi();
     break;
 
+  // case page fault
+  case T_PGFLT:
+    page_fault_va = rcr2();
+    curproc->no_of_page_faults += 1;
+    // #if PRINT
+    // cprintf("In trap : va: %d, pgdir: %d, pid: %d, user: %d\n", page_fault_va, *curproc->pgdir, curproc->pid, tf->cs&3);
+    // #endif
+    // if not init or shell
+    if((curproc->pid > 2) && ((tf->cs&3) == DPL_USER)){
+      // if this has PTE_PG set (checked inside func)
+      if(swap_in_and_out(curproc, page_fault_va)) break;
+    }
+
+
   //PAGEBREAK: 13
   default:
     if(myproc() == 0 || (tf->cs&3) == 0){
@@ -103,8 +123,12 @@ trap(struct trapframe *tf)
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
   if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
+     tf->trapno == T_IRQ0+IRQ_TIMER){
+    
+    // if(myproc()!=0) clearAccessBitForAll(); //clearAccessBit(myproc()->pgdir, myproc()->sz);
+
     yield();
+  }
 
   // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
diff --git a/user.h b/user.h
index 4f99c52..cde687a 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+// custom
+int procdetails(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..c4e7cc4 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,4 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(procdetails)
\ No newline at end of file
diff --git a/vm.c b/vm.c
index 7134cff..0496408 100644
--- a/vm.c
+++ b/vm.c
@@ -6,6 +6,7 @@
 #include "mmu.h"
 #include "proc.h"
 #include "elf.h"
+#include "fs.h"
 
 extern char data[];  // defined by kernel.ld
 pde_t *kpgdir;  // for use in scheduler()
@@ -38,9 +39,12 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
   pde_t *pde;
   pte_t *pgtab;
 
-  pde = &pgdir[PDX(va)];
+  // cprintf("va in walkpgdir is %d", (uint) &va);
+
+  pde = &pgdir[PDX(va)];  // upper 10 bits of the virtual address to find the page directory entry
   if(*pde & PTE_P){
-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+    // cprintf("GOT P\n");
+    pgtab = (pte_t*)P2V(PTE_ADDR(*pde)); // [Address in directory entry] -> to virtual
   } else {
     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
       return 0;
@@ -51,7 +55,7 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
     // entries, if necessary.
     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
   }
-  return &pgtab[PTX(va)];
+  return &pgtab[PTX(va)]; // next 10 bits of the virtual address to find the address of the PTE in the page table page
 }
 
 // Create PTEs for virtual addresses starting at va that refer to
@@ -216,6 +220,46 @@ loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
   return 0;
 }
 
+
+void print_fifo(struct page_struct* linkedlist)
+{
+  struct page_struct* temp = linkedlist;
+  int i=1;
+  while(temp != 0){
+    cprintf("(idx: %d, pgdir: %d, va: %d) -> ", temp->index, *temp->pgdir, temp->va);
+    temp = temp->prev;
+    if(i%3 == 0) cprintf("\n");
+    i += 1;
+
+  }
+  cprintf("\n");
+}
+
+void print_file_fifo(struct file_offsets * linkedlist)
+{
+  struct file_offsets* temp = linkedlist;
+  while(temp != 0){
+    cprintf("%d -> ", temp->index);
+    temp = temp->next;
+  }
+  cprintf("\n");
+}
+
+void print_file(struct proc* curproc)
+{
+  // cprintf("In swap files : ");
+  int i, j=1;
+  for(i=0; i<MAX_TOTAL_PAGES; i++)
+  {
+    if(curproc->all_pages[i].file_index != -1){
+      cprintf("(idx: %d, pgdir: %d, va: %d) -> ", curproc->all_pages[i].index, *curproc->all_pages[i].pgdir, curproc->all_pages[i].va);
+      if(j%3 == 0) cprintf("\n");
+      j += 1;
+    }
+  }
+  cprintf("\n");
+}
+
 // Allocate page tables and physical memory to grow process from oldsz to
 // newsz, which need not be page aligned.  Returns new size or 0 on error.
 int
@@ -223,14 +267,46 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
   char *mem;
   uint a;
+  int page_index;
+
+  struct proc* curproc = myproc();
+
+  #if PRINT 
+    cprintf("\n############################ allocuvm start\n");
+    cprintf("allocating : Current proc id : %d, pgdir %d, oldsz %d, newsz %d\n", curproc->pid,*pgdir, oldsz, newsz);
+  #endif
+
+  /*
+    here shell is forked from init
+    and others are forked from shell?
+
+    so need all to get the info too .. (actually we dont) and only page when pid > 2
+  */
 
   if(newsz >= KERNBASE)
     return 0;
   if(newsz < oldsz)
     return oldsz;
 
-  a = PGROUNDUP(oldsz);
+  a = PGROUNDUP(oldsz); // only grow from oldsz to newsz
+  
   for(; a < newsz; a += PGSIZE){
+    // if MAX_TOTAL_PAGES exceeded
+    if((curproc->pid > 2) && ((curproc->no_of_mem_pages + curproc->no_of_swap_pages) > MAX_TOTAL_PAGES))
+    {
+      panic("has exceeded page limit");
+      return 0;
+    }
+
+    // when oldsz=0, newsz is < MAX_PSYC_PAGES
+    // so can easily do this
+    // write a page to swap and free the file
+    // when no of memory pages has exceed MAX_PSYC_PAGES
+    if((curproc->pid > 2) && (curproc->no_of_mem_pages >= MAX_PSYC_PAGES)){
+      // write and free memory
+      write_page_to_file(curproc);
+    }
+
     mem = kalloc();
     if(mem == 0){
       cprintf("allocuvm out of memory\n");
@@ -244,7 +320,38 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
       kfree(mem);
       return 0;
     }
+
+
+    // paging metadata update
+    page_index = get_free_index(curproc); // get index in table list
+    // enqueue
+    curproc->all_pages[page_index].va = a;
+    enqueue_page(curproc, &curproc->all_pages[page_index]);
+    curproc->all_pages[page_index].pgdir = pgdir;
+    curproc->no_of_mem_pages += 1; // increment no of pages in memory
+    // cprintf("memory grown to %d\n", curproc->no_of_mem_pages);
+    // print_fifo(curproc->tail);
+    #if PRINT 
+      cprintf("Allocated for page index %d, va %d, pgdir %d\n", page_index, a, *pgdir);
+    #endif
   }
+
+  // checking dequeue
+  // if(curproc->pid > 2){
+  //   a = PGROUNDUP(oldsz);
+  //   for(; a < newsz; a += PGSIZE)
+  //   {
+  //     struct page_struct* page = dequeue_page(curproc);
+  //     cprintf("Dequeue : %d and file offset : %d\n", page->index, page->file_index);
+
+  //   }
+  // }
+  
+
+  #if PRINT 
+    print_proc_info(curproc);
+    cprintf("############################ allocuvm end\n");
+  #endif
   return newsz;
 }
 
@@ -257,24 +364,103 @@ deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
   pte_t *pte;
   uint a, pa;
+  int i;
 
   if(newsz >= oldsz)
     return oldsz;
 
+  struct proc* curproc = myproc();
+  struct page_struct* temp;
+
+
+  #if PRINT 
+    cprintf("\n############################ deallocuvm start\n");
+    cprintf("DEALLOCATING : Current proc id : %d, proc pgdir %d, pgdir %d, oldsz %d, newsz %d\n", curproc->pid, *curproc->pgdir, *pgdir, oldsz, newsz);
+  #endif
+
   a = PGROUNDUP(newsz);
   for(; a  < oldsz; a += PGSIZE){
     pte = walkpgdir(pgdir, (char*)a, 0);
     if(!pte)
       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+
+
+    // deallocate a page in swap file
+    else if((*pte & PTE_PG) != 0){
+      *pte = 0;
+      for(i=0; i<MAX_TOTAL_PAGES; i++){
+        if((curproc->all_pages[i].va == a) && (curproc->all_pages[i].pgdir == pgdir) && (curproc->all_pages[i].file_index != -1)){
+          push_file_offsets(curproc, curproc->all_pages[i].file_index);
+
+          #if PRINT 
+            cprintf("Removing page index: %d\n", curproc->all_pages[i].index);
+          #endif
+          curproc->no_of_swap_pages -= 1;
+          curproc->all_pages[i].va = -1;
+          curproc->all_pages[i].pgdir = 0;
+          curproc->all_pages[i].index = -1;
+          curproc->all_pages[i].file_index = -1;
+          curproc->all_pages[i].next = 0;
+          curproc->all_pages[i].prev = 0;
+          break;
+        }
+      }
+    }
+    
+    // deallocate a page in memory
     else if((*pte & PTE_P) != 0){
       pa = PTE_ADDR(*pte);
       if(pa == 0)
         panic("kfree");
+
+      // TODO : is this check needed
+      // cprintf("proc pgdir %d, input pgdir %d\n", *curproc->pgdir, *pgdir);
+      // if(curproc->pgdir == pgdir)
+      {
+        temp = curproc->tail;
+        while(temp != 0)
+        {
+          // cprintf("pgdir %d and ll pgdir %d; va is %d and ll va is %d\n", *pgdir, *temp->pgdir, a, temp->va);
+          if((temp->va == a) && (temp->pgdir == pgdir)){
+            // remove this from linklist
+            if (temp->prev != 0) temp->prev->next = temp->next;
+            if (temp->next != 0) temp->next->prev = temp->prev;
+            // configure head and tail
+            if(temp->prev == 0) curproc->head = temp->next;
+            if(temp->next == 0) curproc->tail = temp->prev;
+            
+            // remove data. this is pointer from all_pages array. that should get changed automatically
+            #if PRINT 
+              cprintf("Removing page index %d\n", temp->index);
+            #endif
+            temp->va = -1;
+            temp->pgdir = 0;
+            temp->prev = 0;
+            temp->next = 0;
+            temp->file_index = -1;
+            temp->index = -1; 
+            // cprintf("after deletion -> ");
+            // print_fifo(curproc->tail);
+
+            curproc->no_of_mem_pages -= 1;
+            break;
+          }
+        
+        temp = temp->prev;
+        }
+      }
+
       char *v = P2V(pa);
       kfree(v);
       *pte = 0;
     }
+
   }
+
+  #if PRINT
+    cprintf("############################ deallocuvm end\n");
+    print_proc_info(curproc);
+  #endif
   return newsz;
 }
 
@@ -284,7 +470,10 @@ void
 freevm(pde_t *pgdir)
 {
   uint i;
-
+  #if PRINT
+    cprintf("free vm for page dir = %d\n", *pgdir);
+  #endif
+  // struct proc* curproc = myproc();
   if(pgdir == 0)
     panic("freevm: no pgdir");
   deallocuvm(pgdir, KERNBASE, 0);
@@ -295,6 +484,7 @@ freevm(pde_t *pgdir)
     }
   }
   kfree((char*)pgdir);
+  // cprintf("Freevm done.\n\n");
 }
 
 // Clear PTE_U on a page. Used to create an inaccessible
@@ -316,7 +506,7 @@ pde_t*
 copyuvm(pde_t *pgdir, uint sz)
 {
   pde_t *d;
-  pte_t *pte;
+  pte_t *pte, *temp_pte;
   uint pa, i, flags;
   char *mem;
 
@@ -325,8 +515,19 @@ copyuvm(pde_t *pgdir, uint sz)
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
       panic("copyuvm: pte should exist");
+    
+    // TODO : recheck this
+    if (*pte & PTE_PG){
+      temp_pte = walkpgdir(d, (void*) i, 1); // allocate page table entries
+      *temp_pte |= PTE_U | PTE_W | PTE_PG;
+      *temp_pte &= ~PTE_P;
+      lcr3(V2P(d));
+      continue;
+    }
+    
     if(!(*pte & PTE_P))
       panic("copyuvm: page not present");
+    
     pa = PTE_ADDR(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
@@ -392,3 +593,307 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
 //PAGEBREAK!
 // Blank page.
 
+
+void
+printPTE(pde_t* pgdir, uint sz){
+  pde_t *pde;
+  pte_t *pgtab, *pte;
+
+  // page tables
+  cprintf("Page tables:\n");
+  cprintf("\tmemory location of page directory = %p\n", *pgdir);
+
+  int i, j, ppn;
+  for(i = 0; i < NPDENTRIES; i += 1){
+    pde = &pgdir[i];
+    if (i >= (KERNBASE >> 22)) break;  // break when kernbase values start
+    if((*pde & PTE_U) && (*pde & PTE_P)){
+      cprintf("\tpdir PTE %d, %d:\n", i, *pde>>12);
+      cprintf("\t\tmemory location of page table = %d\n", PTE_ADDR(*pde));
+      pgtab = (pte_t*)P2V(PTE_ADDR(*pde)); // [Address in directory entry] -> to virtual
+      for(j = 0; j < NPTENTRIES; j += 1){
+        pte = &pgtab[j];
+        if((*pte & PTE_U) && (*pte & PTE_P)){
+          ppn = *pte>>12;
+          cprintf("\t\tptbl PTE %d, %d, %d\n", j, ppn, ppn<<12);
+        }
+      }
+    }
+  }
+
+
+  // mappings
+  cprintf("Page mappings:\n");
+  for(i = 0; i < NPDENTRIES; i += 1){
+    pde = &pgdir[i];
+    if((*pde & PTE_U) && (*pde & PTE_P)){
+      pgtab = (pte_t*)P2V(PTE_ADDR(*pde)); // [Address in directory entry] -> to virtual
+      for(j = 0; j < NPTENTRIES; j += 1){
+        pte = &pgtab[j];
+        if((*pte & PTE_U) && (*pte & PTE_P)){
+          ppn = *pte>>12;
+          cprintf("%d -> %d\n", i*NPTENTRIES+j, ppn);
+        }
+      }
+    }
+  }
+}
+
+
+int swap_in_and_out(struct proc* curproc, uint va){
+  va = PGROUNDDOWN(va);
+  #if PRINT
+    cprintf("\n############################ trap swap inout start\n");
+    cprintf("New va : %d\n", va);
+  #endif
+  
+  // find the appropriate memory
+  int demand_page_index, file_offset=-1;
+  pde_t* pgdir = 0;
+
+  for(demand_page_index=0; demand_page_index<MAX_TOTAL_PAGES; demand_page_index++){
+    // if(curproc->all_pages[demand_page_index].va == va && curproc->all_pages[demand_page_index].pgdir == curproc->pgdir){
+    if(curproc->all_pages[demand_page_index].va == va){// && curproc->all_pages[demand_page_index].file_index != -1){
+      file_offset = curproc->all_pages[demand_page_index].file_index;
+      pgdir = curproc->all_pages[demand_page_index].pgdir;
+      break;
+    }
+  }
+
+  if(file_offset == -1){
+    panic("Page doesn't exist in file. But flag is set");
+    return 0;
+  }
+
+  pte_t* read_pte = walkpgdir(pgdir, (char*) va, 0);
+  if(!(*read_pte & PTE_PG)){
+    cprintf("Not a swapped file case\n");
+    return 0;
+  }
+
+  #if PRINT
+    cprintf("IN TRAP\nmemory location at page index : %d and file offset %d\n", demand_page_index, file_offset);
+  #endif
+
+  // do read op
+  // now update new stuff
+  // allocate new memory
+  char* new_mem = kalloc();
+  memset(new_mem, 0, PGSIZE);
+  read_page_from_file(curproc, demand_page_index, new_mem);
+
+  // if memory full
+  if(curproc->no_of_mem_pages >= MAX_PSYC_PAGES){
+    write_page_to_file(curproc);
+  }
+
+  // map the pages - to old pgdir? 
+  // this adds PTE_P too
+  if(mappages(pgdir, (char*)va, PGSIZE, V2P(new_mem), PTE_W|PTE_U) < 0){
+    panic("allocuvm out of memory after read\n");
+    // cprintf("allocuvm out of memory (2)\n");
+    // kfree(new_mem);
+    return 0;
+  }
+
+  // update PG flag
+  *read_pte &= ~PTE_PG;
+  lcr3(V2P(pgdir));
+  #if PRINT
+    cprintf("############################ trap swap inout end\n");
+  #endif
+  return 1;
+}
+
+
+void
+print_proc_info(struct proc* curproc)
+{
+  // #if PRINT
+  cprintf("PROC STATE ---------------------------------------------------\n");
+  cprintf("Proc ID: %d, PGDIR: %d, MEM_PAGES: %d, SWAP_PAGES: %d, PAGE_FAULTS: %d\n", 
+            curproc->pid, *curproc->pgdir, curproc->no_of_mem_pages, curproc->no_of_swap_pages, curproc->no_of_page_faults);  
+  cprintf("Pages in memory : \n");
+  print_fifo(curproc->tail);
+  cprintf("Pages in file : \n");
+  print_file(curproc);
+  cprintf("Free file index : \n");
+  print_file_fifo(curproc->free_file_pos);
+  cprintf("---------------------------------------------------------------\n");
+  // #endif
+}
+
+
+// doesnt update flags
+void
+read_page_from_file(struct proc* curproc, int demand_page_index, char* new_mem)
+{
+  #if PRINT
+    cprintf("\n## STARTING READ OP ##");
+  #endif
+
+  int read_count=0, frac=2, idx=0;
+  int file_offset = curproc->all_pages[demand_page_index].file_index;
+  char buffer[PGSIZE/frac];
+
+  // read page from file
+  while(idx != frac){
+    memset(buffer, 0, PGSIZE/frac);
+    read_count += readFromSwapFile(curproc, buffer, file_offset*PGSIZE + (idx*(PGSIZE/frac)), PGSIZE/frac);
+    memmove(new_mem + (idx*(PGSIZE/frac)), buffer, PGSIZE/frac);
+    idx += 1;
+  }
+  // if count not okay
+  if (read_count != PGSIZE) {
+    panic("Something wrong with reading from page file");
+  }
+  
+  
+  // update metadata
+  push_file_offsets(curproc, file_offset); // push file offset  as free space
+  enqueue_page(curproc, &curproc->all_pages[demand_page_index]); // enqueue page
+  curproc->all_pages[demand_page_index].file_index = -1; // not in file anymore
+  curproc->no_of_mem_pages += 1; // increment no of pages in memory
+  curproc->no_of_swap_pages -= 1; // decrement no of pages in file
+
+  // NOTICE : did not update flags
+
+  #if PRINT
+    print_proc_info(curproc);
+    cprintf("## FINISHED READ OP ##\n");
+  #endif
+}
+
+void
+write_page_to_file(struct proc* curproc)
+{
+  #if PRINT
+    cprintf("\n## STARTING WRITE OP ##");
+  #endif
+  struct page_struct* temp;
+  int va_replace, temp_file_index;
+
+  // check initial conditions
+  // TODO : for some reason condition not working
+  if(curproc->no_of_swap_pages > MAX_SWAP_PAGES) panic("Maximum amount of pages written in file\n");
+  if(curproc->no_of_mem_pages == 0) panic("No pages in memory to write in file\n");
+
+  // select replacement page
+  // for FIFO its the first page added
+  temp = dequeue_page(curproc);
+  if(temp == 0) panic("Replacement page is invalid\n");
+  va_replace = temp->va;
+  temp_file_index = pop_file_offsets(curproc); // get free file space
+
+  // write op
+  #if PRINT
+    cprintf("Writing page %d into swap file using file index %d and va %d and pgdir %d\n", temp->index, temp_file_index, va_replace, *temp->pgdir);
+  #endif
+
+  // char* buffer = (char*) PTE_ADDR(va_replace);
+  // for(int i=0; i<PGSIZE/2; i++) cprintf("%s ", &buffer[i]);
+  // cprintf("\n");
+  
+  if(writeToSwapFile(curproc, (char*) va_replace, temp_file_index*PGSIZE, PGSIZE) == -1){
+    panic("Error when writing to swap file");
+  }
+  // cprintf("WRITE DONE\n");
+  // update metadata
+  curproc->all_pages[temp->index].file_index = temp_file_index; // update file index info
+  curproc->no_of_swap_pages += 1; // increment no of pages in swap file
+  curproc->no_of_mem_pages -= 1; // decrement no of pages in memory
+
+  // update pte flags
+  // should be already allocated
+  pte_t* write_pte = walkpgdir(curproc->all_pages[temp->index].pgdir, (int*)va_replace, 0);
+  // free this memory
+  kfree((char*)P2V(PTE_ADDR(*write_pte)));
+  // set flags
+  *write_pte |= (PTE_U | PTE_W | PTE_PG);
+  *write_pte &= ~PTE_P; // not present  
+  lcr3(V2P(curproc->all_pages[temp->index].pgdir)); // refresh TLB
+
+  #if PRINT
+    cprintf("After write : \n");
+    print_proc_info(curproc);
+    cprintf("## FINISHED WRITE OP ##\n");
+  #endif
+
+  // print_proc_info(curproc);
+  // cprintf("No of page faults : %d\r", curproc->no_of_page_faults);
+}
+
+
+struct page_struct*
+get_NRU_page(struct proc* curproc)
+{
+  struct page_struct* temp = curproc->tail;
+  // struct page_struct* class1 = 0;
+  struct page_struct* class2 = 0; 
+  struct page_struct* class3 = 0; 
+  struct page_struct* class4 = 0;
+  pte_t* pte;
+
+  // cprintf("\n");
+  while(temp != 0)
+  {
+    // cprintf("searching for index %d\n", temp->index);
+    pte = walkpgdir(temp->pgdir, (char*)temp->va, 0);
+    if(pte == 0){
+      cprintf("WARNING NO PTE AVAILABLE\n");
+      return curproc->tail;
+    }
+    // both accessed and dirty
+    if((*pte & PTE_A) && (*pte & PTE_D)) class4 = temp;
+    // only accessed
+    else if(*pte & PTE_A) class3 = temp;
+    // only dirty
+    else if(*pte & PTE_D) class2 = temp;
+    // neither
+    else {
+      #if PRINT
+        cprintf("Class 1: page index %d\n", temp->index);
+      #endif
+      return temp; // this is class1 
+    }
+    temp = temp->prev;
+  }
+
+  if(class2 != 0) {
+    #if PRINT
+      cprintf("Class 2: page index %d\n", class2->index);
+    #endif
+    return class2;
+  }
+  if(class3 != 0) {
+    #if PRINT
+      cprintf("Class 3: page index %d\n", class3->index);
+    #endif
+    return class3;
+  }
+  if(class4 != 0) {
+    #if PRINT
+      cprintf("Class 4: page index %d\n", class4->index);
+    #endif
+    return class4;
+  }
+
+  return curproc->tail; // default is fifo
+}
+
+
+void
+clearAccessBit(struct proc* curproc){
+  pte_t *pte;
+  struct page_struct* temp=curproc->tail;
+
+  // cprintf("clearing bits\n");
+  while(temp != 0)
+  {
+    pte = walkpgdir(temp->pgdir, (char*)temp->va, 0);
+    if(pte == 0) panic("CANNOT BE PTE\n");
+    *pte &= ~(PTE_A);
+    temp = temp->prev;
+  }
+  
+}
